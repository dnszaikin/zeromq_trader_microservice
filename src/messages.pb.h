// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_messages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsuser_registeredImpl();
void InitDefaultsuser_registered();
void InitDefaultsuser_renamedImpl();
void InitDefaultsuser_renamed();
void InitDefaultsuser_deal_wonImpl();
void InitDefaultsuser_deal_won();
void InitDefaultsuser_connectedImpl();
void InitDefaultsuser_connected();
void InitDefaultsuser_disconnectedImpl();
void InitDefaultsuser_disconnected();
void InitDefaultswrapper_messageImpl();
void InitDefaultswrapper_message();
inline void InitDefaults() {
  InitDefaultsuser_registered();
  InitDefaultsuser_renamed();
  InitDefaultsuser_deal_won();
  InitDefaultsuser_connected();
  InitDefaultsuser_disconnected();
  InitDefaultswrapper_message();
}
}  // namespace protobuf_messages_2eproto
class user_connected;
class user_connectedDefaultTypeInternal;
extern user_connectedDefaultTypeInternal _user_connected_default_instance_;
class user_deal_won;
class user_deal_wonDefaultTypeInternal;
extern user_deal_wonDefaultTypeInternal _user_deal_won_default_instance_;
class user_disconnected;
class user_disconnectedDefaultTypeInternal;
extern user_disconnectedDefaultTypeInternal _user_disconnected_default_instance_;
class user_registered;
class user_registeredDefaultTypeInternal;
extern user_registeredDefaultTypeInternal _user_registered_default_instance_;
class user_renamed;
class user_renamedDefaultTypeInternal;
extern user_renamedDefaultTypeInternal _user_renamed_default_instance_;
class wrapper_message;
class wrapper_messageDefaultTypeInternal;
extern wrapper_messageDefaultTypeInternal _wrapper_message_default_instance_;

// ===================================================================

class user_registered : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:user_registered) */ {
 public:
  user_registered();
  virtual ~user_registered();

  user_registered(const user_registered& from);

  inline user_registered& operator=(const user_registered& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  user_registered(user_registered&& from) noexcept
    : user_registered() {
    *this = ::std::move(from);
  }

  inline user_registered& operator=(user_registered&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_registered& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const user_registered* internal_default_instance() {
    return reinterpret_cast<const user_registered*>(
               &_user_registered_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(user_registered* other);
  friend void swap(user_registered& a, user_registered& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline user_registered* New() const PROTOBUF_FINAL { return New(NULL); }

  user_registered* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const user_registered& from);
  void MergeFrom(const user_registered& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(user_registered* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint64 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint64 user_id() const;
  void set_user_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:user_registered)
 private:
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_name();
  void clear_has_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 user_id_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
  friend void ::protobuf_messages_2eproto::InitDefaultsuser_registeredImpl();
};
// -------------------------------------------------------------------

class user_renamed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:user_renamed) */ {
 public:
  user_renamed();
  virtual ~user_renamed();

  user_renamed(const user_renamed& from);

  inline user_renamed& operator=(const user_renamed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  user_renamed(user_renamed&& from) noexcept
    : user_renamed() {
    *this = ::std::move(from);
  }

  inline user_renamed& operator=(user_renamed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_renamed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const user_renamed* internal_default_instance() {
    return reinterpret_cast<const user_renamed*>(
               &_user_renamed_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(user_renamed* other);
  friend void swap(user_renamed& a, user_renamed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline user_renamed* New() const PROTOBUF_FINAL { return New(NULL); }

  user_renamed* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const user_renamed& from);
  void MergeFrom(const user_renamed& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(user_renamed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint64 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint64 user_id() const;
  void set_user_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:user_renamed)
 private:
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_name();
  void clear_has_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 user_id_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
  friend void ::protobuf_messages_2eproto::InitDefaultsuser_renamedImpl();
};
// -------------------------------------------------------------------

class user_deal_won : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:user_deal_won) */ {
 public:
  user_deal_won();
  virtual ~user_deal_won();

  user_deal_won(const user_deal_won& from);

  inline user_deal_won& operator=(const user_deal_won& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  user_deal_won(user_deal_won&& from) noexcept
    : user_deal_won() {
    *this = ::std::move(from);
  }

  inline user_deal_won& operator=(user_deal_won&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_deal_won& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const user_deal_won* internal_default_instance() {
    return reinterpret_cast<const user_deal_won*>(
               &_user_deal_won_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(user_deal_won* other);
  friend void swap(user_deal_won& a, user_deal_won& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline user_deal_won* New() const PROTOBUF_FINAL { return New(NULL); }

  user_deal_won* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const user_deal_won& from);
  void MergeFrom(const user_deal_won& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(user_deal_won* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  const ::std::string& time() const;
  void set_time(const ::std::string& value);
  #if LANG_CXX11
  void set_time(::std::string&& value);
  #endif
  void set_time(const char* value);
  void set_time(const char* value, size_t size);
  ::std::string* mutable_time();
  ::std::string* release_time();
  void set_allocated_time(::std::string* time);

  // required uint64 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint64 user_id() const;
  void set_user_id(::google::protobuf::uint64 value);

  // required int64 amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:user_deal_won)
 private:
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_time();
  void clear_has_time();
  void set_has_amount();
  void clear_has_amount();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr time_;
  ::google::protobuf::uint64 user_id_;
  ::google::protobuf::int64 amount_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
  friend void ::protobuf_messages_2eproto::InitDefaultsuser_deal_wonImpl();
};
// -------------------------------------------------------------------

class user_connected : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:user_connected) */ {
 public:
  user_connected();
  virtual ~user_connected();

  user_connected(const user_connected& from);

  inline user_connected& operator=(const user_connected& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  user_connected(user_connected&& from) noexcept
    : user_connected() {
    *this = ::std::move(from);
  }

  inline user_connected& operator=(user_connected&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_connected& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const user_connected* internal_default_instance() {
    return reinterpret_cast<const user_connected*>(
               &_user_connected_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(user_connected* other);
  friend void swap(user_connected& a, user_connected& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline user_connected* New() const PROTOBUF_FINAL { return New(NULL); }

  user_connected* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const user_connected& from);
  void MergeFrom(const user_connected& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(user_connected* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint64 user_id() const;
  void set_user_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:user_connected)
 private:
  void set_has_user_id();
  void clear_has_user_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 user_id_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
  friend void ::protobuf_messages_2eproto::InitDefaultsuser_connectedImpl();
};
// -------------------------------------------------------------------

class user_disconnected : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:user_disconnected) */ {
 public:
  user_disconnected();
  virtual ~user_disconnected();

  user_disconnected(const user_disconnected& from);

  inline user_disconnected& operator=(const user_disconnected& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  user_disconnected(user_disconnected&& from) noexcept
    : user_disconnected() {
    *this = ::std::move(from);
  }

  inline user_disconnected& operator=(user_disconnected&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_disconnected& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const user_disconnected* internal_default_instance() {
    return reinterpret_cast<const user_disconnected*>(
               &_user_disconnected_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(user_disconnected* other);
  friend void swap(user_disconnected& a, user_disconnected& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline user_disconnected* New() const PROTOBUF_FINAL { return New(NULL); }

  user_disconnected* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const user_disconnected& from);
  void MergeFrom(const user_disconnected& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(user_disconnected* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 user_id = 2;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::uint64 user_id() const;
  void set_user_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:user_disconnected)
 private:
  void set_has_user_id();
  void clear_has_user_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 user_id_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
  friend void ::protobuf_messages_2eproto::InitDefaultsuser_disconnectedImpl();
};
// -------------------------------------------------------------------

class wrapper_message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:wrapper_message) */ {
 public:
  wrapper_message();
  virtual ~wrapper_message();

  wrapper_message(const wrapper_message& from);

  inline wrapper_message& operator=(const wrapper_message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  wrapper_message(wrapper_message&& from) noexcept
    : wrapper_message() {
    *this = ::std::move(from);
  }

  inline wrapper_message& operator=(wrapper_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const wrapper_message& default_instance();

  enum MsgCase {
    kUserRegisteredMsg = 1,
    kUserRenamedMsg = 2,
    kUserDealWonMsg = 3,
    kUserConnectedMsg = 4,
    kUserDisconnectedMsg = 51,
    MSG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const wrapper_message* internal_default_instance() {
    return reinterpret_cast<const wrapper_message*>(
               &_wrapper_message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(wrapper_message* other);
  friend void swap(wrapper_message& a, wrapper_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline wrapper_message* New() const PROTOBUF_FINAL { return New(NULL); }

  wrapper_message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const wrapper_message& from);
  void MergeFrom(const wrapper_message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(wrapper_message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .user_registered user_registered_msg = 1;
  bool has_user_registered_msg() const;
  void clear_user_registered_msg();
  static const int kUserRegisteredMsgFieldNumber = 1;
  const ::user_registered& user_registered_msg() const;
  ::user_registered* release_user_registered_msg();
  ::user_registered* mutable_user_registered_msg();
  void set_allocated_user_registered_msg(::user_registered* user_registered_msg);

  // optional .user_renamed user_renamed_msg = 2;
  bool has_user_renamed_msg() const;
  void clear_user_renamed_msg();
  static const int kUserRenamedMsgFieldNumber = 2;
  const ::user_renamed& user_renamed_msg() const;
  ::user_renamed* release_user_renamed_msg();
  ::user_renamed* mutable_user_renamed_msg();
  void set_allocated_user_renamed_msg(::user_renamed* user_renamed_msg);

  // optional .user_deal_won user_deal_won_msg = 3;
  bool has_user_deal_won_msg() const;
  void clear_user_deal_won_msg();
  static const int kUserDealWonMsgFieldNumber = 3;
  const ::user_deal_won& user_deal_won_msg() const;
  ::user_deal_won* release_user_deal_won_msg();
  ::user_deal_won* mutable_user_deal_won_msg();
  void set_allocated_user_deal_won_msg(::user_deal_won* user_deal_won_msg);

  // optional .user_connected user_connected_msg = 4;
  bool has_user_connected_msg() const;
  void clear_user_connected_msg();
  static const int kUserConnectedMsgFieldNumber = 4;
  const ::user_connected& user_connected_msg() const;
  ::user_connected* release_user_connected_msg();
  ::user_connected* mutable_user_connected_msg();
  void set_allocated_user_connected_msg(::user_connected* user_connected_msg);

  // optional .user_disconnected user_disconnected_msg = 51;
  bool has_user_disconnected_msg() const;
  void clear_user_disconnected_msg();
  static const int kUserDisconnectedMsgFieldNumber = 51;
  const ::user_disconnected& user_disconnected_msg() const;
  ::user_disconnected* release_user_disconnected_msg();
  ::user_disconnected* mutable_user_disconnected_msg();
  void set_allocated_user_disconnected_msg(::user_disconnected* user_disconnected_msg);

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:wrapper_message)
 private:
  void set_has_user_registered_msg();
  void set_has_user_renamed_msg();
  void set_has_user_deal_won_msg();
  void set_has_user_connected_msg();
  void set_has_user_disconnected_msg();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  union MsgUnion {
    MsgUnion() {}
    ::user_registered* user_registered_msg_;
    ::user_renamed* user_renamed_msg_;
    ::user_deal_won* user_deal_won_msg_;
    ::user_connected* user_connected_msg_;
    ::user_disconnected* user_disconnected_msg_;
  } msg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_messages_2eproto::TableStruct;
  friend void ::protobuf_messages_2eproto::InitDefaultswrapper_messageImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// user_registered

// required uint64 user_id = 1;
inline bool user_registered::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_registered::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_registered::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_registered::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 user_registered::user_id() const {
  // @@protoc_insertion_point(field_get:user_registered.user_id)
  return user_id_;
}
inline void user_registered::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:user_registered.user_id)
}

// required string name = 2;
inline bool user_registered::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_registered::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_registered::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_registered::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& user_registered::name() const {
  // @@protoc_insertion_point(field_get:user_registered.name)
  return name_.GetNoArena();
}
inline void user_registered::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:user_registered.name)
}
#if LANG_CXX11
inline void user_registered::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:user_registered.name)
}
#endif
inline void user_registered::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:user_registered.name)
}
inline void user_registered::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:user_registered.name)
}
inline ::std::string* user_registered::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:user_registered.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_registered::release_name() {
  // @@protoc_insertion_point(field_release:user_registered.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_registered::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:user_registered.name)
}

// -------------------------------------------------------------------

// user_renamed

// required uint64 user_id = 1;
inline bool user_renamed::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_renamed::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_renamed::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_renamed::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 user_renamed::user_id() const {
  // @@protoc_insertion_point(field_get:user_renamed.user_id)
  return user_id_;
}
inline void user_renamed::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:user_renamed.user_id)
}

// required string name = 2;
inline bool user_renamed::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_renamed::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_renamed::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_renamed::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& user_renamed::name() const {
  // @@protoc_insertion_point(field_get:user_renamed.name)
  return name_.GetNoArena();
}
inline void user_renamed::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:user_renamed.name)
}
#if LANG_CXX11
inline void user_renamed::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:user_renamed.name)
}
#endif
inline void user_renamed::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:user_renamed.name)
}
inline void user_renamed::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:user_renamed.name)
}
inline ::std::string* user_renamed::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:user_renamed.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_renamed::release_name() {
  // @@protoc_insertion_point(field_release:user_renamed.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_renamed::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:user_renamed.name)
}

// -------------------------------------------------------------------

// user_deal_won

// required uint64 user_id = 1;
inline bool user_deal_won::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_deal_won::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_deal_won::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_deal_won::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 user_deal_won::user_id() const {
  // @@protoc_insertion_point(field_get:user_deal_won.user_id)
  return user_id_;
}
inline void user_deal_won::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:user_deal_won.user_id)
}

// required string time = 2;
inline bool user_deal_won::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_deal_won::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_deal_won::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_deal_won::clear_time() {
  time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_time();
}
inline const ::std::string& user_deal_won::time() const {
  // @@protoc_insertion_point(field_get:user_deal_won.time)
  return time_.GetNoArena();
}
inline void user_deal_won::set_time(const ::std::string& value) {
  set_has_time();
  time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:user_deal_won.time)
}
#if LANG_CXX11
inline void user_deal_won::set_time(::std::string&& value) {
  set_has_time();
  time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:user_deal_won.time)
}
#endif
inline void user_deal_won::set_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_time();
  time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:user_deal_won.time)
}
inline void user_deal_won::set_time(const char* value, size_t size) {
  set_has_time();
  time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:user_deal_won.time)
}
inline ::std::string* user_deal_won::mutable_time() {
  set_has_time();
  // @@protoc_insertion_point(field_mutable:user_deal_won.time)
  return time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_deal_won::release_time() {
  // @@protoc_insertion_point(field_release:user_deal_won.time)
  clear_has_time();
  return time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_deal_won::set_allocated_time(::std::string* time) {
  if (time != NULL) {
    set_has_time();
  } else {
    clear_has_time();
  }
  time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), time);
  // @@protoc_insertion_point(field_set_allocated:user_deal_won.time)
}

// required int64 amount = 3;
inline bool user_deal_won::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_deal_won::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_deal_won::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_deal_won::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::int64 user_deal_won::amount() const {
  // @@protoc_insertion_point(field_get:user_deal_won.amount)
  return amount_;
}
inline void user_deal_won::set_amount(::google::protobuf::int64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:user_deal_won.amount)
}

// -------------------------------------------------------------------

// user_connected

// required uint64 user_id = 1;
inline bool user_connected::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_connected::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_connected::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_connected::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 user_connected::user_id() const {
  // @@protoc_insertion_point(field_get:user_connected.user_id)
  return user_id_;
}
inline void user_connected::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:user_connected.user_id)
}

// -------------------------------------------------------------------

// user_disconnected

// required uint64 user_id = 2;
inline bool user_disconnected::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_disconnected::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_disconnected::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_disconnected::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 user_disconnected::user_id() const {
  // @@protoc_insertion_point(field_get:user_disconnected.user_id)
  return user_id_;
}
inline void user_disconnected::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:user_disconnected.user_id)
}

// -------------------------------------------------------------------

// wrapper_message

// optional .user_registered user_registered_msg = 1;
inline bool wrapper_message::has_user_registered_msg() const {
  return msg_case() == kUserRegisteredMsg;
}
inline void wrapper_message::set_has_user_registered_msg() {
  _oneof_case_[0] = kUserRegisteredMsg;
}
inline void wrapper_message::clear_user_registered_msg() {
  if (has_user_registered_msg()) {
    delete msg_.user_registered_msg_;
    clear_has_msg();
  }
}
inline ::user_registered* wrapper_message::release_user_registered_msg() {
  // @@protoc_insertion_point(field_release:wrapper_message.user_registered_msg)
  if (has_user_registered_msg()) {
    clear_has_msg();
      ::user_registered* temp = msg_.user_registered_msg_;
    msg_.user_registered_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::user_registered& wrapper_message::user_registered_msg() const {
  // @@protoc_insertion_point(field_get:wrapper_message.user_registered_msg)
  return has_user_registered_msg()
      ? *msg_.user_registered_msg_
      : *reinterpret_cast< ::user_registered*>(&::_user_registered_default_instance_);
}
inline ::user_registered* wrapper_message::mutable_user_registered_msg() {
  if (!has_user_registered_msg()) {
    clear_msg();
    set_has_user_registered_msg();
    msg_.user_registered_msg_ = new ::user_registered;
  }
  // @@protoc_insertion_point(field_mutable:wrapper_message.user_registered_msg)
  return msg_.user_registered_msg_;
}

// optional .user_renamed user_renamed_msg = 2;
inline bool wrapper_message::has_user_renamed_msg() const {
  return msg_case() == kUserRenamedMsg;
}
inline void wrapper_message::set_has_user_renamed_msg() {
  _oneof_case_[0] = kUserRenamedMsg;
}
inline void wrapper_message::clear_user_renamed_msg() {
  if (has_user_renamed_msg()) {
    delete msg_.user_renamed_msg_;
    clear_has_msg();
  }
}
inline ::user_renamed* wrapper_message::release_user_renamed_msg() {
  // @@protoc_insertion_point(field_release:wrapper_message.user_renamed_msg)
  if (has_user_renamed_msg()) {
    clear_has_msg();
      ::user_renamed* temp = msg_.user_renamed_msg_;
    msg_.user_renamed_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::user_renamed& wrapper_message::user_renamed_msg() const {
  // @@protoc_insertion_point(field_get:wrapper_message.user_renamed_msg)
  return has_user_renamed_msg()
      ? *msg_.user_renamed_msg_
      : *reinterpret_cast< ::user_renamed*>(&::_user_renamed_default_instance_);
}
inline ::user_renamed* wrapper_message::mutable_user_renamed_msg() {
  if (!has_user_renamed_msg()) {
    clear_msg();
    set_has_user_renamed_msg();
    msg_.user_renamed_msg_ = new ::user_renamed;
  }
  // @@protoc_insertion_point(field_mutable:wrapper_message.user_renamed_msg)
  return msg_.user_renamed_msg_;
}

// optional .user_deal_won user_deal_won_msg = 3;
inline bool wrapper_message::has_user_deal_won_msg() const {
  return msg_case() == kUserDealWonMsg;
}
inline void wrapper_message::set_has_user_deal_won_msg() {
  _oneof_case_[0] = kUserDealWonMsg;
}
inline void wrapper_message::clear_user_deal_won_msg() {
  if (has_user_deal_won_msg()) {
    delete msg_.user_deal_won_msg_;
    clear_has_msg();
  }
}
inline ::user_deal_won* wrapper_message::release_user_deal_won_msg() {
  // @@protoc_insertion_point(field_release:wrapper_message.user_deal_won_msg)
  if (has_user_deal_won_msg()) {
    clear_has_msg();
      ::user_deal_won* temp = msg_.user_deal_won_msg_;
    msg_.user_deal_won_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::user_deal_won& wrapper_message::user_deal_won_msg() const {
  // @@protoc_insertion_point(field_get:wrapper_message.user_deal_won_msg)
  return has_user_deal_won_msg()
      ? *msg_.user_deal_won_msg_
      : *reinterpret_cast< ::user_deal_won*>(&::_user_deal_won_default_instance_);
}
inline ::user_deal_won* wrapper_message::mutable_user_deal_won_msg() {
  if (!has_user_deal_won_msg()) {
    clear_msg();
    set_has_user_deal_won_msg();
    msg_.user_deal_won_msg_ = new ::user_deal_won;
  }
  // @@protoc_insertion_point(field_mutable:wrapper_message.user_deal_won_msg)
  return msg_.user_deal_won_msg_;
}

// optional .user_connected user_connected_msg = 4;
inline bool wrapper_message::has_user_connected_msg() const {
  return msg_case() == kUserConnectedMsg;
}
inline void wrapper_message::set_has_user_connected_msg() {
  _oneof_case_[0] = kUserConnectedMsg;
}
inline void wrapper_message::clear_user_connected_msg() {
  if (has_user_connected_msg()) {
    delete msg_.user_connected_msg_;
    clear_has_msg();
  }
}
inline ::user_connected* wrapper_message::release_user_connected_msg() {
  // @@protoc_insertion_point(field_release:wrapper_message.user_connected_msg)
  if (has_user_connected_msg()) {
    clear_has_msg();
      ::user_connected* temp = msg_.user_connected_msg_;
    msg_.user_connected_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::user_connected& wrapper_message::user_connected_msg() const {
  // @@protoc_insertion_point(field_get:wrapper_message.user_connected_msg)
  return has_user_connected_msg()
      ? *msg_.user_connected_msg_
      : *reinterpret_cast< ::user_connected*>(&::_user_connected_default_instance_);
}
inline ::user_connected* wrapper_message::mutable_user_connected_msg() {
  if (!has_user_connected_msg()) {
    clear_msg();
    set_has_user_connected_msg();
    msg_.user_connected_msg_ = new ::user_connected;
  }
  // @@protoc_insertion_point(field_mutable:wrapper_message.user_connected_msg)
  return msg_.user_connected_msg_;
}

// optional .user_disconnected user_disconnected_msg = 51;
inline bool wrapper_message::has_user_disconnected_msg() const {
  return msg_case() == kUserDisconnectedMsg;
}
inline void wrapper_message::set_has_user_disconnected_msg() {
  _oneof_case_[0] = kUserDisconnectedMsg;
}
inline void wrapper_message::clear_user_disconnected_msg() {
  if (has_user_disconnected_msg()) {
    delete msg_.user_disconnected_msg_;
    clear_has_msg();
  }
}
inline ::user_disconnected* wrapper_message::release_user_disconnected_msg() {
  // @@protoc_insertion_point(field_release:wrapper_message.user_disconnected_msg)
  if (has_user_disconnected_msg()) {
    clear_has_msg();
      ::user_disconnected* temp = msg_.user_disconnected_msg_;
    msg_.user_disconnected_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::user_disconnected& wrapper_message::user_disconnected_msg() const {
  // @@protoc_insertion_point(field_get:wrapper_message.user_disconnected_msg)
  return has_user_disconnected_msg()
      ? *msg_.user_disconnected_msg_
      : *reinterpret_cast< ::user_disconnected*>(&::_user_disconnected_default_instance_);
}
inline ::user_disconnected* wrapper_message::mutable_user_disconnected_msg() {
  if (!has_user_disconnected_msg()) {
    clear_msg();
    set_has_user_disconnected_msg();
    msg_.user_disconnected_msg_ = new ::user_disconnected;
  }
  // @@protoc_insertion_point(field_mutable:wrapper_message.user_disconnected_msg)
  return msg_.user_disconnected_msg_;
}

inline bool wrapper_message::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void wrapper_message::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline wrapper_message::MsgCase wrapper_message::msg_case() const {
  return wrapper_message::MsgCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
